load 000 RR RR
store 001 RR RR
add 010 RR RR
beq 011 RR RR #we need to make this more clear.
slt 100 RR RR
init 101 RR ii
slr 110 00 RR
and 110 01 RR
jump 110 10 RR
xor 111 RR	RR

# This is part two of project 2 searching for best matching     # score and count. 
# M[8] = beginning of Pattern_Array
# M[7] = temp score # 2
# M[6] = temp score holder
# M[5] = best_matching_count
# M[4] = best_mathing_Score
# M[3] = target
# M[2] = 16 a counter for each compare
# M[1] = the address of beginning of pattern
# M[0] = be used as a counter for number of patterns

	init r0, 1				
	init r1, 1 
	init r2, 1 
	init r3, 1 
	add r3, r2 #r3 = 2
	add r2, r3 #r2 = 3
	add r3, r3 	# r3 = 4
	init r0, 0 
	add r0, r3 # r0 = 4
	add r3, r3	# r3 = 8
	store r3, r1	#M[1] = 8; the address of beginning of pattern
	add r3, r3 	# r3 = 16
	store r3, r2 	#M[2] = 16 a counter for each compare
	add r3, r3 	# r3 = 32
	init r1, 0 
	add r1, r3 # r1= 32
	add r3, r3 	# r3 = 64
	add r3, r1 # r3 = 96
	add r3, r0 # r3 = 100
	init r0, 0 
	store r3, r0 # saves 100 into M[0] to be used as a counter
	init r0, 0 
	***jump r1
Big loop:	
	init r0, 1
	init r1, 1
	add r1, r1 #2 
	add r1, r1 #4
	add r0, r0 #2
	add r0, r1 #6
	load r2, r1 #r2 = M[4] best score
	load r3, r0 #r3 = M[6] temp best score
	slt r2, r3 # if r2<r3 r0=1
	init r1, 0
	beq r0, r1 # skip saving new value into best score
	store r3, r0 # if r2<r3 then M[4] = r3
	init r1, 1
	add r1, r1 #r1=2
	add r1, r1 #r1=4
	add r0, r1	#r0=10
	add r0, r1 #r0=14
	init r1, -1
	add r0, r1
	beq r2, r3
	jump r0 #jump up 13
	init r0, 1
	init r1, 1
	add r0, r0 #r0=2
	add r0, r0 #r0=4
	add r0, r1 #r0 = 5
	load r1, r0 #loads best matching count
	init r2, 1
	add r1, r2
	store r1, r0
	load r1, r2
	add r1, r2
	jump r1 # jumps by 9
	init r0, 1
	init r1, 1
	add r0, r0
	add r0, r0
	add r0, r1 #r0 = 5
	load r1, r0 #loads best matching count
	init r1, 0
	store r1, r0 #sets M[5] back to 0 if new score 
	init r1, 1
	add r1, r0 #6
	init r0, 0
	store r0, r1 
	init r0, 0 # where it actually begins
	init r1, -1
	load r3, r0
	add r3, r1
	store r3, r0
	init r1, 1
	load r3, r0 # r3 = M[0] (the counter)
	load r3, r1 	#loads the value for loading the pattern array
	load r2, r3	#loads the value of the pattern array
	add r1, r1 #make r1 = 2
	init r0, 1
	add r1, r0
	load r1, r1 	#load the target word
	xor r1, r2 #the number of 0s in r1 is = to # of bits match
	not r1 #NOT's r1 to that the 0's become 1's
#loop:
	init r3, 1
	init r0, -1
	init r2, 0
	add r3, r3 #r3=2
	add r3, r3 #r3=4
	add r2, r3 #r2= 4
	add r3, r3 #r3=8
	add r2, r3 #r2=12
	add r3, r3 #r3=16
	add r3, r2 #r3=28
	add r3, r0 #r3=27
	init r2, 1
	init r0, 0	
	add r2, r2
	load r2, r2
	beq r2, r0 # if M[2] = goes to jump at mem 
	beq r0, r0 # jumps line 77 if above statment is not true
	jump r3 #jumps to line *big loop* in code for new pattern
	init r3, 1
	init r2, 0
	add r2, r1 # r2 = 16bit NXOR of target & pattern 
	and r2, r3 #if the first bit matches result =1 
	init r0, 0
	add r3, r3 #r3 = 2
	add r0, r3
	add r3, r3 #r3 = 4
	add r3, r0 # r3 = 6
	load r0, r3 	#loads the existing value for best score temp
	add r2, r0 	#adds the result of and to the best temp score counter
	store r2, r3	#saves r2 back to best temp score
	srl r1
	init r2, 1
	add r2, r2 #r2 = 2
	load r3, r2	#loads the counter (from 16 down)
	init r0, -1
	add r3, r0
	store r3, r2 # saves the counter back in after -1
	init r0, 1
	add r0, r0 # r0 = 2
	add r2, r2	# r2 = 4
	add r0, r2	# r0 = 6
	load r3, r0	# loads the current temporary score
