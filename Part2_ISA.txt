load 000 RR RR
store 001 RR RR
add 010 RR RR
branch 011 RR RR #we need to make this more clear.
jump 100 iiii
init 101 RR ii
slr 110 00 RR
and 110 01 RR
sll 110 10 RR
xor 111 RR	RR

# This is part two of project 2 searching for best matching     # score and count. Assuming M[3] is the target, 			     # M[4] = best_mathing_Score, M[5] = best_matching_count
# M[8] = beginning of Pattern_Array
#

	init r0, 1				
	init r1, 1 #r1 = 1
	init r2, 1 #r2 = 1
	init r3, 1 #r3 = 1
	add r3, r2 #r3 = 2
	add r2, r3 #r2 = 3
	sw r3, r1 	#M[2] = address of target
	sll r3 	# r3 = 4
	init r0, 0 
	add r0, r3 # r0 = 4
	sll r3	# r3 = 8
	sw r3, r1	#M[1] = 8; the address of beginning of pattern
	sll r3 	# r3 = 16
	sw r3, r2 	#M[3] = 16 a counter for each compare
	sll r3 	# r3 = 32
	init r1, 0 
	add r1, r3 # r1= 32
	sll r3 	# r3 = 64
	add r3, r1 # r3 = 96
	add r3, r0 # r3 = 100
	init r0, 0 
	sw r3, r0 # saves 100 into M[0] to be used as a counter

loop:	# location in instr. mem. should be 6 (for jump)

	init r0, 0
	lw r3, r0 # r3 = M[0] (the counter)
	branch r3, r0 #branch if r3 is = 0 to 
	jump done #put immediate in when the number of lines to 				#jump is known


	init r1, 1
	lw r3, r1 	#loads the value for loading the pattern array
	lw r2, r3	#loads the value of the pattern array
	add r1, r1 #make r1 = 2
	lw r1, r1 #load the target word
	init r3, -1
	xor r1, r2 #the number of 0s in r1 is = to # of bits match
	xor r1, r3	 #NOT's r1 to that the 0's become 1's

#matcher:
	init r3, 1
	and r1, r3 #if the first bit matches result =1 
	sll r3 #r3 = 2
	sll r3 #r3 = 4
	lw r0, r3 #loads the existing value for best score
	add r1, r0 #adds 1
	sw r1, r0
	
	
	
















	